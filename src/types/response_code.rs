use std::convert::TryFrom;
use std::fmt;

/// An NNTP [Response Code](https://tools.ietf.org/html/rfc3977#section-3.2)
///
///
/// This library supports all codes specified in [RFC 3977](https://tools.ietf.org/html/rfc3977#appendix-C).
///
/// Because proprietary NNTP extensions may define their own codes, there is no way for this library
/// to know about all of the codes that exist. Unknown codes will be stored as `u16`s.
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum ResponseCode {
    /// A response code implemented by the library
    Known(Kind),
    /// A response code not known to the library
    ///
    /// For example, a code specified by an NNTP extension might not return a known code.
    Unknown(u16),
}

impl ResponseCode {
    /// The response is a 1xx
    pub fn is_info(&self) -> bool {
        let code = u16::from(*self);
        code >= 100 && code < 200
    }

    /// The response is a 2xx
    pub fn is_success(&self) -> bool {
        let code = u16::from(*self);
        code >= 200 && code < 300
    }

    /// The response is a 3xx
    pub fn is_success_so_far(&self) -> bool {
        let code = u16::from(*self);
        code >= 300 && code < 400
    }

    /// The response is a 4xx
    pub fn is_failure(&self) -> bool {
        let code = u16::from(*self);
        code >= 400 && code < 500
    }

    /// The response is a 5xx
    pub fn is_error(&self) -> bool {
        let code = u16::from(*self);
        code >= 500 && code < 600
    }

    /// Returns true if the response is a Known multiline response
    ///
    /// Unknown responses are always false
    pub fn is_multiline(&self) -> bool {
        match self {
            ResponseCode::Known(k) => k.is_multiline(),
            ResponseCode::Unknown(_) => false,
        }
    }
}

impl From<u16> for ResponseCode {
    fn from(code: u16) -> Self {
        Kind::try_from(code).map_or_else(|_e| Self::Unknown(code), Self::Known)
    }
}

impl From<ResponseCode> for u16 {
    fn from(code: ResponseCode) -> Self {
        match code {
            ResponseCode::Known(kind) => kind as u16,
            ResponseCode::Unknown(code) => code,
        }
    }
}

impl From<&ResponseCode> for u16 {
    fn from(code: &ResponseCode) -> Self {
        match *code {
            ResponseCode::Known(kind) => kind as u16,
            ResponseCode::Unknown(code) => code,
        }
    }
}

impl fmt::Display for ResponseCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let code: u16 = self.into();
        write!(f, "{}", code)
    }
}

/// NNTP response code types
///
/// ## References
///
/// * [RFC 3977 Section 3.2](https://tools.ietf.org/html/rfc3977#section-3.2)
/// * [RFC 3977 Appendix C](https://tools.ietf.org/html/rfc3977#appendix-C)
#[repr(u16)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, num_enum::TryFromPrimitive)]
#[allow(missing_docs)]
pub enum Kind {
    Help = 100,
    Capabilities = 101,
    Date = 111,

    PostingAllowed = 200,
    PostingProhibited = 201,
    ConnectionClosing = 205,
    /// This is generated by `GROUP` and `LISTGROUP` and the bodies are different depending
    /// on which command is used. Buyer beware!
    GroupSelected = 211,
    List = 215,
    Article = 220,

    Head = 221,
    Body = 222,
    ArticleExists = 223,
    Overview = 224,

    ArticleTransferredOk = 235,

    IHaveSendArticle = 335,
    PostSendArticle = 340,

    TemporarilyUnavailable = 400,
    WrongMode = 401,
    InternalError = 403,
    NoSuchNewsgroup = 411,
    NoNewsgroupSelected = 412,
    InvalidCurrentArticleNumber = 420,
    NoNextArticle = 421,
    NoPreviousArticle = 422,
    NoArticleWithNumber = 423,
    NoArticleWithMessageId = 430,
    ArticleNotWanted = 435,
    TransferFailed = 436,
    TransferRejected = 437,
    PostingNotPermitted = 440,
    PostingFailed = 441,
    AuthenticationRequired = 480,
    SecureConnectionRequired = 483,

    UnknownCommand = 500,
    SyntaxError = 501,
    PermanentlyUnavailable = 502,
    FeatureNotSupported = 503,
    Base64Error = 504,

    // Authentication https://tools.ietf.org/html/rfc4643
    AuthenticationAccepted = 281,
    PasswordRequired = 381,
    AuthenticationFailed = 481,
    AuthenticationOutOfSequence = 482,
}

impl Kind {
    /// Whether or not the code corresponds to a multiline response
    ///
    /// NNTP requires that extension makers specify whether a response code
    /// corresponds to a single-line or multi-line response.
    ///
    /// With the exception of code `211`, this means that the response code reliably tells you
    /// whether or not there is a data block section for a response.
    ///
    /// ## Response Code 211
    ///
    /// Per [RFC 3977](https://tools.ietf.org/html/rfc3977#section-3.2), due to "historical reasons",
    /// Response Code 211 corresponds to a multi-line response when returned from `LISTGROUP`
    /// and a single-line response when returned by the `GROUP` command.
    ///
    /// Rather than making the entire library more complex for this singular exception, the library
    /// assumes that code 211 DOES NOT correspond to a multi-line response.
    pub fn is_multiline(&self) -> bool {
        matches!(*self as u16, 100..=101 | 215 | 220..=222 | 224..=225 | 230..=231)
    }
}

impl From<Kind> for u16 {
    fn from(code: Kind) -> Self {
        code as u16
    }
}

impl From<Kind> for ResponseCode {
    fn from(kind: Kind) -> Self {
        ResponseCode::Known(kind)
    }
}
